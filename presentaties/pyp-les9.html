<!doctype html>
<html>
	<head>
		<title>Python Programming: Les 9</title>
		<link rel="stylesheet" type="text/css" href="../css/reset.css">
		<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../highlight/styles/googlecode.css">
		<link href="https://fonts.googleapis.com/css?family=Karla:700|Open+Sans" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../css/agnes.css">
		<link rel="stylesheet" type="text/css" href="../css/htmlgallery.css">
		<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/194554/scroll-converter.min.js'></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script src='../highlight/highlight.pack.js'></script>
		<script src="../js/script.js" defer></script>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="utf-8">
	</head>
	<body data-markdown="true">
				<section>
							# Python Programming
							## Python toepassingen en virtuele Python-omgevingen
							#### Kristof Michiels
				</section>
				<section>
							## Inhoud
							- Python toepassingen
							- Virtuele Python-omgevingen
							- De Python interactieve shell
				</section>
				<section class="chapter">
							## Python toepassingen
				</section>
				<section>
							## Een eenvoudige toepassing maken
							- Any group of Python statements placed sequentially in a file can be used as a program, or script
							- useful to introduce additional structure
							- Op zijn eenvoudigst: creating a controlling function in a file and calling that function
							- this structure can give you more options and control when you create larger applications, so it’s a good idea to make using it a habit from the beginning.

							```Python
							def main():
							    print("Kijk eens aan, ons eerste programma ;-)") 
								
							main()
							```
				</section>
				<section>
							## Een eenvoudige toepassing maken

							Nog eens herhalen => bij import verhinderen dat main wordt uitgevoerd
				</section>
				<section>
							## Een script starten van de command-line
							- If you’re using Linux/UNIX, make sure that Python is on your path and you’re in the same directory as your script. Then type the following on your command line to start the script:

							BASH SHELL VOOR WINDOWS!

							```bash
							python mijn_script.py
							```
				</section>
				<section>
							## Command-line argumenten

							import sys def main():

print("this is our second test script file")

print(sys.argv) main()

If you call this with the line

python script2.py arg1 arg2 3

you get

this is our second test script file ['script2.py', 'arg1', 'arg2', '3']

You can see that the command-line arguments have been stored in sys.argv as a list of strings.
				</section>
				<section>
							## Redirecting the input and output of a script
							You can redirect the input and/or the output for a script by using command-line options. To show this technique, I use this short script.

							```Python
							import sys 
							def main():
							    contents = sys.stdin.read()
								# Reads from stdin into contents
							    sys.stdout.write(contents.replace(sys.argv[1], sys.argv[2]))
								# Replaces first argument with second

							main()
							```

							This script reads its standard input and writes to its standard output whatever it reads, with all occurrences of its first argument replaced with its second argument. Called as follows, the script places in outfile a copy of infile with all occurrences of zero replaced by 0:

							python replace.py zero 0 < infile > outfile

							Note that this script works on UNIX, but on Windows, redirection of input and/or output works only if you start a script from a command-prompt window.

							In general, the line

							python script.py arg1 arg2 arg3 arg4 < infile > outfile

							has the effect of having any input or sys.stdin operations directed out of infile and any print or sys.stdout operations directed into outfile. The effect is as though you set sys.stdin to infile with 'r' (read) mode and sys.stdout to outfile with 'w' (write):

							python replace.py a A < infile >> outfile

							This line causes the output to be appended to outfile rather than to overwrite it, as happened in the previous example.

							You can also pipe in the output of one command as the input of another command:

							python replace.py 0 zero < infile | python replace.py 1 one > outfile

							This code results in outfile containing the contents of infile, with all occurrences of 0 changed to zero and all occurrences of 1 changed to one.
				</section>
				<section>
							## De argparse module

							p. 145-146
				</section>
				<section>
							## De fileinput module

							p. 146-148
				</section>
				<section>
							## Een script onmiddellijk uitvoerbaar maken

							p. 148-150
				</section>
				<section>
							## Programma's en modules
							For small scripts that contain only a few lines of code, a single function works well. But if the script grows beyond this size, separating your controlling function from the rest of the code is a good option to take. T
				</section>
				<section class="chapter">
							## Modules
				</section>
				<section>
							## Wat zijn modules en hoe gebruik je ze?
							- In de les over functies hebben we reeds gezien hoe we functies uit het ene bestand kunnen importeren om ze te gebruiken in een ander bestand
							- We beschrijven een module als elk bestand dat Python objecten beschrijft, dus ook de bestanden die we importeerden zijn modules 
							- Als een bestand mijn_programma.py heeft als naam dan is mijn_programma de modulenaam
							- Je gebruikt het import statement om een externe module te linken. Objecten uit externe module kunnen dan gebruikt worden als modulenaam.objectnaam
							- Nogmaals: je kan bekijken hoe dit precies werkt in de les over functies
				</section>
				<section>
							## Modules als organisatieblokken voor grotere projecten

							- Modules worden gebruikt om grotere projecten beheersbaar te houden. Zo ook bij Python zelf
							- De meeste standaard Python functies zijn niet in de core van de taal ingebouwd maar worden aangeboden via specifieke modules, die je kan inladen (importeren) wanneer nodig
							- We noemen deze importeerbare reeks modules de [Python standard library](https://docs.python.org/3/library/) 
							- Het is aan te raden om, wanneer je programma's langer worden, je code gaat opsplitsen in modules. Ook naar mogelijk later hergebruik van functionaliteit is dit een goeie manier van werken

				</section>
				<section>
							## Modules
							- Externe modules bevatten meestal Python broncode, maar ze kunnen ook gecompileerde C of C++ objectbestanden zijn
							- C(++) of Python: beide types worden op dezelfde manier gebruikt
							- Naast het groeperen van Python objecten helpen modules ook naamgevingsconflicten beheersen. Een objectnaam hoeft enkel uniek te zijn binnen de namespace van een module
				</section>
				<section>
							## Een voorbeeld van een module

							```Python
							# mijn_rekenmodule.py:
							"""mijn_rekenmodule - Een voorbeeld van een rekenmodule - bevat een variabele en een 
							functie """
							pi = 3.14159
							def oppervlakte(straal):
							    """oppervlakte(straal): geef de oppervlakte van een cirkel terug met straal 
								'straal'.""" 
								global pi 
								return(pi * straal * straal)
							```
	
							```Python
							# ander_programma.py:
							import mijn_rekenmodule
							print(mijn_rekenmodule.pi)
							print(mijn_rekenmodule.oppervlakte(3))
							```
				</section>

				<section>
							## Het module search path

							Exactly where Python looks for modules is defined in a variable called path, which you can access through a module called sys. Enter the following:

>>> import sys

>>> sys.path

_list of directories in the search path_

The value shown in place of _list of directories in the search path_ depends on the configuration of your system. Regardless of the details, the string indicates a list of directories that Python searches (in order) when attempting to execute an import statement. The first module found that satisfies the import request is used. If there’s no satisfactory module in the module search path, an ImportError exception is raised.

If you’re using IDLE, you can graphically look at the search path and the modules on it by using the Path Browser window, which you can start from the File menu of the Python shell window.

The sys.path variable is initialized from the value of the environment (operating system) variable PYTHONPATH, if it exists, or from a default value that’s dependent on your installation. In addition, whenever you run a Python script, the sys.path variable for that script has the directory containing the script inserted as its first element, which provides a convenient way of determining where the executing Python program is located. In an interactive session such as the previous one, the first element of sys.path is set to the empty string, which Python takes as meaning that it should first look for modules in the current directory.
				</section>
				<section>
							## Waar je modules plaatsen?

							In the example that starts this chapter, the mymath module is accessible to Python because (1) when you execute Python interactively, the first element of sys.path is "", telling Python to look for modules in the current directory; and (2) you executed Python in the directory that contained the mymath.py file. In a production environment, neither of these conditions typically is true. You won’t be running Python interactively, and Python code files won’t be located in your current directory. To ensure that your programs can use the modules you coded, you need to:

 Place your modules in one of the directories that Python normally searches for modules.

 Place all the modules used by a Python program in the same directory as the

program.

 Create a directory (or directories) to hold your modules, and modify the sys

.path variable so that it includes this new directory (or directories).

Of these three options, the first is apparently the easiest and is also an option that you should never choose unless your version of Python includes local code directories in its default module search path. Such directories are specifically intended for site-specific
code (that is, code specific to your machine) and aren’t in danger of being overwritten by a new Python install because they’re not part of the Python installation. If your sys.path refers to such directories, you can put your modules there.

The second option is a good choice for modules that are associated with a particular program. Just keep them with the program.

The third option is the right choice for site-specific modules that will be used in more than one program at that site. You can modify sys.path in various ways. You can assign to it in your code, which is easy, but doing so hardcodes directory locations into your program code. You can set the PYTHONPATH environment variable, which is relatively easy, but it may not apply to all users at your site; or you can add it to the default search path by using a .pth file.

Examples of how to set PYTHONPATH are in the Python documentation in the Python Setup and Usage section (under Command line and environment). The directory or directories you set it to are prepended to the sys.path variable. If you use PYTHONPATH, be careful that you don’t define a module with the same name as one of the existing library modules that you’re using. If you do that your module will be found before the library module. In some cases, this may be what you want, but probably not often.

You can avoid this issue by using a .pth file. In this case, the directory or directories you added will be appended to sys.path. The last of these mechanisms is best illustrated by an example. On Windows, you can place a .pth file in the directory pointed to by sys.prefix. Assume your sys.prefix is c:\program files \python, and place the file in this listing in that directory.
				</section>

                <section class="chapter">
							## Virtuele Python-omgevingen
                </section>
                <section>
							## Virtuele Python-omgevingen
							- Handig Python feature en essentiële kennis voor Python developers
							- Per projectfolder een privé-kopie maken van de interpreter en gebruikte dependencies
							- Dependencies zijn alle software-componenten (zoals externe libraries) die nodig zijn om je project succesvol te kunnen runnen
							- Op deze manier zijn meerdere projecten op je systeem mogelijk, elk met eigen Python-versie en componenten
							- Wij gebruiken hier venv: https://docs.python.org/3/library/venv.html. Weet dat er verschillende alternatieven zijn.
                </section>
				<section>
							## Een virtuele omgeving opzetten

							- Het venv-script wordt meegeleverd met de Python-interpreter
							- De tweede venv op de lijn is de naam die we kiezen voor onze virtuele Python-omgeving. Je kan een andere kiezen, maar is zowat standaard om "venv" te kiezen
							- Na uitvoeren van het script wordt een venv folder aangemaakt waarin de interpreter en eventueel ook later geïnstalleerde dependencies wordt opgeslagen

							```Bash
							python3 -m venv venv
							```
				</section>
				<section>
							## Een virtuele omgeving activeren

							- We activeren de venv via een script in de virtuele omgeving
							- Zichtbaar aan de prompt van je bash/zsh terminal dat venv actief is

							```Bash
							# unix, mac:
							source venv/bin/activate

							# windows:
							venv\Scripts\activate
							```

							Windows + powershell: "Venv won't activate on this system" => https://dev.to/shriekdj/python-venv-or-virtualenv-wont-activate-on-windows-3e2
				</section>
				<section>
							## Een virtuele omgeving de-activeren

							- Gebruik "deactivate" in de terminal om de virtuele omgeving te verlaten

							```Bash
							deactivate
							```
				</section>
				<section>
							## Python installer pip

							- We gebruiken pip om externe dependencies te installeren. Meegeleverd met Python en dus ook aanwezig in de virtuele Python-omgeving
							- Pip is een recursief acronym dat staat voor "Pip Installs Packages" of "preferred installer program" :-) 
							- Zorg er voor dat je virtuele omgeving geactiveerd is als je packages installeert
							- Bekijk de verzameling van gepubliceerde Python packages op PyPI: https://pypi.org/
							- Bijvoorbeeld om de requests-library te installeren:

							```Bash
							pip install requests
							```
				</section>
				<section>
							## Doorgeven of deployen van een virtual environment

							- Dumpen naar een bestand:
								- pip freeze > requirements.txt
							
							- Omgeving aanmaken op basis van een bestand:
								- pip install -r requirements.txt

				</section>
				<section class="chapter">
							## De Python interactieve shell
				</section>
				<section>
							## De Python interactieve shell

							- Als je de Python interpreter uitvoert zonder script in een terminal kom je terecht in de interactieve shell
							- Veel Python handboeken beginnen met de interactieve interpreter. Ik vermeld het hier, net voor we programma's gaan beginnen schrijven :-)
							- Waarom? Het is een handige tool om tijdens het programmeren snel iets uit te proberen
							- Ik gebruik het heel vaak in die context
							- De shell verlaat je met exit()
				</section>
				<section>
							## De Python interactieve shell

							```bash
							python
							>>> tekst = "Hallo"
							>>> for letter in tekst:
							...     print(letter)
							... 
							H
							a
							l
							l
							o
							>>> exit()
							```
				</section>
				<section>
							## Python Programming - les 9 - kristof.michiels01@ap.be
				</section>
	</body>
</html>