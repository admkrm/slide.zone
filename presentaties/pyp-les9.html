<!doctype html>
<html>
	<head>
		<title>Python Programming: Les 9</title>
		<link rel="stylesheet" type="text/css" href="../css/reset.css">
		<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../highlight/styles/googlecode.css">
		<link href="https://fonts.googleapis.com/css?family=Karla:700|Open+Sans" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../css/agnes.css">
		<link rel="stylesheet" type="text/css" href="../css/htmlgallery.css">
		<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/194554/scroll-converter.min.js'></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script src='../highlight/highlight.pack.js'></script>
		<script src="../js/script.js" defer></script>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="utf-8">
	</head>
	<body data-markdown="true">
				<section>
							# Python Programming
							## Python toepassingen en virtuele Python-omgevingen
							#### Kristof Michiels
				</section>
				<section>
							## Inhoud
							- Python toepassingen
							- Virtuele Python-omgevingen
							- De Python interactieve shell
				</section>
				<section class="chapter">
							## Python toepassingen
				</section>
				<section>
							## Een eenvoudige toepassing maken
							- Een Python programma of script = elke hoeveelheid van opeenvolgende Python statements
							- Als het aantal statements toeneemt is het zinvol om bijkomende structuur toe te voegen
							- Een goeie en eenvoudige eerste stap: een controlerende functie (bvb main()) toevoegen in een bestand en deze functie aanroepen

							```Python
							def main():
							    print("Kijk eens aan, ons eerste programma ;-)") 
								
							main()
							```
				</section>
				<section>
							## Verhinderen dat bij importeren code wordt uitgevoerd				

							- Met een if-statement kan je checken of het bestand al dan niet geïmporteerd werd uitgevoerd 
							- Wanneer de interpreter een bronbestand inleest zet het een aantal speciale variabelen, zoals \_\_name__
							- Als je de module als programma runt (en dus niet importeert) dan kent de interpreter de string "__main__" toe aan deze variabele
							- Goeie manier van werken: steeds onderstaande opzet gebruiken


							```Python
							def main():
							    print("Kijk eens aan, ons eerste programma ;-)") 
								
							if __name__ == "__main__":
								main()
							```
				</section>
				<section>
							## Een script starten van de command-line
							- We hebben tot nog toe onze programma's uitgevoerd met de run-knop van VSCode, of via de terminal sessie die VSCode vervolgens voor ons aanmaakt
							- We kunnen een Python ook starten via een externe terminal sessie: _python mijn_script.py_
							- Bij Linux/Unix besturingssystemen spreken we een bash of zsh-shell
							- Windows gebruikers kunnen ook een bash command-line verkrijgen via Git Bash. Installeer git via https://git-scm.com/ en Git Bash wordt automatisch mee-geïnstalleerd
							- Je kan na installatie ook binnen VSCode kiezen voor een Bash terminal sessie 
				</section>
				<section>
							## Command-line argumenten

							- Onze programma's kunnen input meekrijgen via command-line argumenten (zie ook les 6): _python mijn_script.py arg1 arg2 argn_
							- Deze argumenten worden bijgehouden in een variabele argv (argument vector) die deel uitmaakt van de sys (system) module
							- argv is een list, waarvan de elementen met type-conversie functies kunnen worden omgezet naar het gewenste datatype
							- De sys-module is nodig en wordt geïmporteerd met het import statement
							- Het eerste element van de sys.argv-list is de naam van het uitgevoerde bestand
							- De volgende elementen in de list zijn de argumenten die na de bestandsnaam zijn meegegeven
				</section>
				<section>
							## Command-line argumenten

							```Python
							import sys

							print(f"Dit programma heeft {len(sys.argv)} command-line argumenten.")
							print(f"De naam van het bestand is {sys.argv[0]}")

							if len(sys.argv) > 1:
								print("De overige argumenten zijn:")
								for i in range(1, len(sys.argv)):
									print(sys.argv[i])
							```
				</section>
				<section>
							## De in- en output van een programma kanaliseren

							- We doen dit door gebruik te maken van command-line opties en van sys.stdin.read() en sys.stdout.write()
							- Je krijgt er toegang mee naar en tot via:_python mijn_script.py zero 0 < input.txt > output.txt_

							```Python
							import sys 
							def main():
							    output_string = "Hallo wereld"
							    mijn_input = sys.stdin.read()
							    sys.stdout.write(output_string)

							main()
							```
				</section>
				<section>
							## De in- en output van een programma kanaliseren

							- Toevoegen aan output-bestand ipv overschrijven:_python mijn_script.py zero 0 >> output.txt_
							- De output van een script doorgeven als input van een ander script (met het pipe-symbool): python script1.py | python script2.py
				</section>
				<section>
							## De argparse module

							- Je kan configure a script to accept command-line options as well as arguments
							- The argparse module provides support for parsing different types of arguments and can even generate usage messages
							- To use the argparse module, you create an instance of ArgumentParser, populate it with arguments, and then read both the optional and positional arguments		
				</section>
				<section>
							## De argparse module

							```Python
							from argparse import ArgumentParser

							def main():
							    parser = ArgumentParser() parser.add_argument("indent", type=int, help="indent for report") parser.add_argument("input_file", help="read data from this file")
							    parser.add_argument("-f", "--file", dest="filename", help="write report to FILE", metavar="FILE")
							    parser.add_argument("-x", "--xray", help="specify xray strength factor") parser.add_argument("-q", "--quiet", action="store_false", dest="verbose", default=True, help="don't print status messages to stdout")
							    args = parser.parse_args()
							    print("arguments:", args) 
							
							main()
							```
				</section>
				<section>
							## De argparse module

							- Deze code creates an instance of ArgumentParser and then adds two positional arguments, indent and input_file, which are the arguments entered after all of the optional arguments have been parsed 
							- Positional arguments are those without a prefix character (usually ("-") and are required, and in this case, the indent argument must also be parsable as an int
							- The next line adds an optional filename argument with either '-f' or '--file'
							- The final option added, the "quiet" option, also adds the ability to turn off the verbose option, which is True by default (action="store_false"). The fact that these options begin with the prefix character "-" tells the parser that they’re optional
							- The final argument, "-q", also has a default value (True, in this case) that will be set if the option isn’t specified. The action="store_false" parameter specifies that if the argument is specified, a value of False will be stored in the destination
				</section>
				<section>
							## De argparse module
							- The argparse module returns a Namespace object containing the arguments as attributes. You can get the values of the arguments by using dot notation. If there’s no argument for an option, its value is None
							- Thus, if you call the previous script with the line: _python opts.py -x100 -q -f outfile 2 arg2_
							- Geeft volgend resultaat: arguments: Namespace(filename='outfile', indent=2, input_file='arg2', verbose=False, xray='100')
							- If an invalid argument is found, or if a required argument isn’t given, parse_args raises an error
							- _python opts.py -x100 -r_ geeft: usage: opts.py [-h] [-f FILE] [-x XRAY] [-q] indent input_file opts.py: error: the following arguments are required: indent, input_file
				</section>
				<section>
							## Een script onmiddellijk uitvoerbaar maken

							p. 148-150
				</section>
				<section>
							## Code organiseren in modules
							- In de les over functies hebben we reeds gezien hoe we functies uit het ene bestand kunnen importeren om ze te gebruiken in een ander bestand
							- We beschrijven een module als elk bestand dat Python objecten beschrijft, dus ook de bestanden die we importeerden zijn modules 
							- Als een bestand mijn_programma.py heeft als naam dan is mijn_programma de modulenaam
							- Je gebruikt het import statement om een externe module te linken. Objecten uit externe module kunnen dan gebruikt worden als modulenaam.objectnaam
							- Nogmaals: je kan bekijken hoe dit precies werkt in de les over functies
				</section>
				<section>
							## Modules als organisatieblokken voor grotere projecten

							- Modules worden gebruikt om grotere projecten beheersbaar te houden
							- Ook Python zelf werkt op modulaire manier. De meeste standaard Python functies zijn niet in de core van de taal ingebouwd maar worden aangeboden via specifieke modules, die je kan importeren wanneer nodig
							- We noemen deze importeerbare reeks modules de [Python standard library](https://docs.python.org/3/library/) 
							- Het is aan te raden om, wanneer je programma's langer worden, je code gaat opsplitsen in modules. Ook naar mogelijk later hergebruik van functionaliteit is dit een goeie manier van werken

				</section>
				<section>
							## Modules
							- Externe modules bevatten meestal Python broncode, maar ze kunnen ook gecompileerde C of C++ objectbestanden zijn
							- C(++) of Python: beide types worden op dezelfde manier gebruikt
							- Naast het groeperen van Python objecten helpen modules ook naamgevingsconflicten beheersen. Een objectnaam hoeft enkel uniek te zijn binnen de namespace van een module
				</section>
				<section>
							## Een voorbeeld van een module

							```Python
							# mijn_rekenmodule.py:
							"""mijn_rekenmodule - Een voorbeeld van een rekenmodule - bevat een variabele en een 
							functie """
							pi = 3.14159
							def oppervlakte(straal):
							    """oppervlakte(straal): geef de oppervlakte van een cirkel terug met straal 
								'straal'.""" 
								global pi 
								return(pi * straal * straal)
							```
	
							```Python
							# ander_programma.py:
							import mijn_rekenmodule
							print(mijn_rekenmodule.pi)
							print(mijn_rekenmodule.oppervlakte(3))
							```
				</section>
				<section>
							## Klassen onderbrengen in modules...
							
							```Python
							#module.py
							class Boek():
								def __init__(self, titel):
									self.titel = titel
							```

							```Python
							import module

							boek1 = module.Boek("Brave New World")
							boek2 = module.Boek("World War Z")

							print(boek1)
							print(boek1.titel)
							```

							Doe je op dezelfde manier als met functies. Het houdt je code georganiseerd en gestructureerd.
				</section>
                <section class="chapter">
							## Virtuele Python-omgevingen
                </section>
                <section>
							## Virtuele Python-omgevingen
							- Handig Python feature en essentiële kennis voor Python developers
							- Per projectfolder een privé-kopie maken van de interpreter en gebruikte dependencies
							- Dependencies zijn alle software-componenten (zoals externe libraries) die nodig zijn om je project succesvol te kunnen runnen
							- Op deze manier zijn meerdere projecten op je systeem mogelijk, elk met eigen Python-versie en componenten
							- Wij gebruiken hier venv: https://docs.python.org/3/library/venv.html. Weet dat er verschillende alternatieven zijn.
                </section>
				<section>
							## Een virtuele omgeving opzetten

							- Het venv-script wordt meegeleverd met de Python-interpreter
							- De tweede venv op de lijn is de naam die we kiezen voor onze virtuele Python-omgeving. Je kan een andere kiezen, maar is zowat standaard om "venv" te kiezen
							- Na uitvoeren van het script wordt een venv folder aangemaakt waarin de interpreter en eventueel ook later geïnstalleerde dependencies wordt opgeslagen

							```Bash
							python3 -m venv venv
							```
				</section>
				<section>
							## Een virtuele omgeving activeren

							- We activeren de venv via een script in de virtuele omgeving
							- Zichtbaar aan de prompt van je bash/zsh terminal dat venv actief is

							```Bash
							# unix, mac:
							source venv/bin/activate

							# windows:
							venv\Scripts\activate
							```

							Windows + powershell: "Venv won't activate on this system" => https://dev.to/shriekdj/python-venv-or-virtualenv-wont-activate-on-windows-3e2
				</section>
				<section>
							## Een virtuele omgeving de-activeren

							- Gebruik "deactivate" in de terminal om de virtuele omgeving te verlaten

							```Bash
							deactivate
							```
				</section>
				<section>
							## Python installer pip

							- We gebruiken pip om externe dependencies te installeren. Meegeleverd met Python en dus ook aanwezig in de virtuele Python-omgeving
							- Pip is een recursief acronym dat staat voor "Pip Installs Packages" of "preferred installer program" :-) 
							- Zorg er voor dat je virtuele omgeving geactiveerd is als je packages installeert
							- Bekijk de verzameling van gepubliceerde Python packages op PyPI: https://pypi.org/
							- Bijvoorbeeld om de requests-library te installeren:

							```Bash
							pip install requests
							```
				</section>
				<section>
							## Doorgeven of deployen van een virtual environment

							- Dumpen naar een bestand:
								- pip freeze > requirements.txt
							
							- Omgeving aanmaken op basis van een bestand:
								- pip install -r requirements.txt

				</section>
				<section class="chapter">
							## De Python interactieve shell
				</section>
				<section>
							## De Python interactieve shell

							- Als je de Python interpreter uitvoert zonder script in een terminal kom je terecht in de interactieve shell
							- Veel Python handboeken beginnen met de interactieve interpreter. Ik vermeld het hier, net voor we programma's gaan beginnen schrijven :-)
							- Waarom? Het is een handige tool om tijdens het programmeren snel iets uit te proberen
							- Ik gebruik het heel vaak in die context
							- De shell verlaat je met exit()
				</section>
				<section>
							## De Python interactieve shell

							```bash
							python
							>>> tekst = "Hallo"
							>>> for letter in tekst:
							...     print(letter)
							... 
							H
							a
							l
							l
							o
							>>> exit()
							```
				</section>
				<section>
							## Python Programming - les 9 - kristof.michiels01@ap.be
				</section>
	</body>
</html>