<!doctype html>
<html>
	<head>
		<title>Python Development: Les 3</title>
		<link rel="stylesheet" type="text/css" href="../css/reset.css">
		<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../highlight/styles/googlecode.css">
		<link href="https://fonts.googleapis.com/css?family=Karla:700|Open+Sans" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../css/agnes.css">
		<link rel="stylesheet" type="text/css" href="../css/htmlgallery.css">
		<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/194554/scroll-converter.min.js'></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script src='../highlight/highlight.pack.js'></script>
		<script src="../js/script.js" defer></script>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="utf-8">
	</head>
	<body data-markdown="true">
				<section>
							# Python Development
							## Functies
							#### Kristof Michiels
				</section>
				<section>
							## Inhoud
							- As the programs that we write grow, we need to take steps to make them easier to develop and debug. One way that we can do this is by breaking the program’s code into sections called functions
							- Functions serve several important purposes: They let us write code once and then call it from many locations, they allow us to test different parts of our solution individually, and they allow us to hide (or at least set aside) the details once we have completed part of our program
							- Functions achieve these goals by allowing the programmer to name and set aside a collection of Python statements for later use. Then our program can cause those statements to execute whenever they are needed. The statements are named by defining a function. The statements are executed by calling a function. When the statements in a function finish executing, control returns to the location where the function was called and the program continues to execute from that location. 
				</section>
				<section>
							## Functies

							The programs that you have written previously called functions like print, input, int and float. All of these functions have already been defined by the people that created the Python programming language, and these functions can be called in any Python program. In this chapter you will learn how to define and call your own functions, in addition to calling those that have been defined previously.
							A function definition begins with a line that consists of def, followed by the name of the function that is being defined, followed by an open parenthesis, a close parenthesis and a colon. This line is followed by the body of the function, which is the collection of statements that will execute when the function is called. As with the bodies of if statements and loops, the bodies of functions are indented. A function’s body ends before the next line that is indented the same amount as (or less than) the line that begins with def. 
				</section>
				<section class="chapter">
							## De basis van functies
				</section>
				<section>
							## Basisvoorbeeld

							```Python
							def gebruiker_groeten():
							    """Display a simple greeting."""
							    print("Hallo daar!")

							gebruiker_groeten()
							```
							
							Korte beschrijving...
				</section>
				<section>
							## De basis van functies

							- while the drawBox function has been defined, it is never called. Defining the function sets these statements aside for future use and associates the name drawBox with them, but it does not execute them. A Python program that consists of only these lines is a valid program, but it will not generate any output when it is executed.
							The drawBox function is called by using its name, followed by an open paren- thesis and a close parenthesis. Adding the following line to the end of the previous program (without indenting it) will call the function and cause the box to be drawn.
							- Adding a second copy of this line will cause a second box to be drawn and adding a third copy of it will cause a third box to be drawn. More generally, a function can be called as many times as needed when solving a problem, and those calls can be made from many different locations within the program. The statements in the body of the function execute every time the function is called. When the function returns execution continues with the statement immediately after the function call.
				</section>
				<section>
							## Functies met parameters

							The drawBox function works correctly. It draws the particular box that it was intended to draw, but it is not flexible, and as a result, it is not as useful as it could be. In particular, our function would be more flexible and useful if it could draw boxes of many different sizes.
							Many functions take arguments which are values provided inside the parentheses when the function is called. The function receives these argument values in parameter variables that are included inside the parentheses when the function is defined. The number of parameter variables in a function’s definition indicates the number of arguments that must be supplied when the function is called.
							We can make the drawBox function more useful by adding two parameters to its definition. These parameters, which are separated by a comma, will hold the width of the box and the height of the box respectively. The body of the function uses the values in the parameter variables to draw the box, as shown below. An if statement and the quit function are used to end the program immediately if the arguments provided to the function are invalid.
				</section>
				<section>
							## Functies met parameters

							```python
							## Draw a box outlined with asterisks and filled with spaces. 
							# @param width the width of the box
							# @param height the height of the box
							def drawBox(width, height):
							# A box that is smaller than 2x2 cannot be drawn by this function
							if width < 2 or height < 2:
								print("Error: The width or height is too small.")
								quit()
							# Draw the top of the box
							print("*" * width)
							# Draw the sides of the box
							for i in range(height - 2):
								print("*" + " " * (width - 2) + "*")
							# Draw the bottom of the box
							print("*" * width)
							```
				</section>
				<section>
							## Functies met parameters

							- Two arguments must be supplied when the drawBox function is called because its definition includes two parameter variables. When the function executes the value of the first argument will be placed in the first parameter variable, and similarly, the value of the second argument will be placed in the second parameter variable. For example, the following function call draws a box with a width of 15 characters and a height of 4 characters. Additional boxes can be drawn with different sizes by calling the function again with different arguments.
							drawBox(15, 4)
							- In its current form the drawBox function always draws the outline of the box with asterisk characters and it always fills the box with spaces. While this may work well in many circumstances there could also be times when the programmer needs a box drawn or filled with different characters. To accommodate this, we are going to update drawBox so that it takes two additional parameters which specify the outline and fill characters respectively. The body of the function must also be updated to use these additional parameter variables, as shown below. A call to the drawBox function which outlines the box with at symbols and fills the box with periods is included at the end of the program.
				</section>
				<section>
							## Functies met parameters

							```python
							## Draw a box.
							# @param width the width of the box
							# @param height the height of the box
							# @param outline the character used for the outline of the box # @param fill the character used to fill the box
							def drawBox(width, height, outline, fill):
							# A box that is smaller than 2x2 cannot be drawn by this function
							if width < 2 or height < 2:
								print("Error: The width or height is too small.")
								quit()
							# Draw the top of the box
							print(outline * width)
							# Draw the sides of the box
							for i in range(height - 2):
								print(outline + fill * (width - 2) + outline)
								# Draw the bottom of the box
								print(outline * width) 
							# Demonstrate the drawBox function
							drawBox(14, 5, "@", ".")
							```
				</section>
				<section>
							## Functies met parameters

							The programmer will have to include the outline and fill values (in addition to the width and height) every time this version of drawBox is called. While needing to do so might be fine in some circumstances, it will be frustrating when asterisk and space are used much more frequently than other character combinations because these arguments will have to be repeated every time the function is called. To overcome this, we will add default values for the outline and fill parameters to the function’s definition. The default value for a parameter is separated from its name by an equal sign, as shown below.

							```python
							def drawBox(width, height, outline="*", fill=" "):
							```
				</section>
				<section>
							## Functies met parameters

							Once this change is made drawBox can be called with two, three or four argu- ments. If drawBox is called with two arguments, the first argument will be placed in the width parameter variable and the second argument will be placed in the height parameter variable. The outline and fill parameter variables will hold their default values of asterisk and space respectively. These default values are used because no arguments were provided for these parameters when the function was called.
							Now consider the following call to drawBox:

							```python
							drawBox(14, 5, "@", ".")
							```
				</section>
				<section>
							## Functies met parameters

							This function call includes four arguments. The first two arguments are the width and height, and they are placed into those parameter variables. The third argument is the outline character. Because it has been provided, the default outline value (asterisk) is replaced with the provided value, which is an at symbol. Similarly, because the call includes a fourth argument, the default fill value is replaced with a period. The box that results from the preceding call to drawBox is shown below.

							```python
							@@@@@@@@@@@@@@
							@............@
							@............@
							@............@
							@@@@@@@@@@@@@@
							```
				</section>
				<section>
							## Variabelen in functies

							When a variable is created inside a function the variable is local to that function. This means that the variable only exists when the function is executing and that it can only be accessed within the body of that function. The variable ceases to exist when the function returns, and as such, it cannot be accessed after that time. The drawBox
							function uses several variables to perform its task. These include parameter variables such as width and fill that are created when the function is called, as well as the for loop control variable, i, that is created when the loop begins to execute. All of these are local variables that can only be accessed within this function. Vari- ables created with assignment statements in the body of a function are also local variables.
				</section>
				<section>
							## Returnwaarden

							Our box-drawing function prints characters on the screen. While it takes argu- ments that specify how the box will be drawn, the function does not compute a result that needs to be stored in a variable and used later in the program. But many functions do compute such a value. For example, the sqrt function in the math module computes the square root of its argument and returns this value so that it can be used in subsequent calculations. Similarly, the input function reads a value typed by the user and then returns it so that it can be used later in the program. Some of the functions that you write will also need to return values.
							A function returns a value using the return keyword, followed by the value that will be returned. When the return executes the function ends immediately and control returns to the location where the function was called. For example, the following statement immediately ends the function’s execution and returns 5 to the location from which it was called.
				</section>
				<section>
							## Returnwaarden

							Functions that return values are often called on the right side of an assignment statement, but they can also be called in other contexts where a value is needed. Exam- ples of such include an if statement or while loop condition, or as an argument to another function, such as print or range.
							A function that does not return a result does not need to use the return keyword because the function will automatically return after the last statement in the function’s body executes. However, a programmer can use the return keyword, without a trailing value, to force the function to return at an earlier point in its body. Any function, whether it returns a value or not, can include multiple return statements. Such a function will return as soon as any of the return statements execute.
							Consider the following example. A geometric sequence is a sequence of terms that begins with some value, a, followed by an infinite number of additional terms. Each term in the sequence, beyond the first, is computed by multiplying its immediate predecessor by r, which is referred to as the common ratio. As a result, the terms in the sequence are a, ar, ar2, ar3, .... When r is 1, the sum of the first n terms of a geometric sequence is a × n. When r is not 1, the sum of the first n terms of a geometric sequence can be computed using the following formula.
				</section>
				<section>
							## Returnwaarden

							A function can be written that computes the sum of the first n terms of any geometric sequence. It will require 3 parameters: a, r and n, and it will need to return one result, which is the sum of the first n terms. The code for the function is shown below.

							```python
							## Compute the sum of the first n terms of a geometric sequence. # @param a the first term in the sequence
							# @param r the common ratio for the sequence
							# @param n the number of terms to include in the sum
							# @return the sum of the first n term of the sequence
							def sumGeometric(a, r, n):
							# Compute and return the sum when the common ratio is 1 if r == 1:
							return a * n
							# Compute and return the sum when the common ratio is not 1
							s = a * (1 - r ** n) / (1 - r)
							return s
							```
				</section>
				<section>
							## Returnwaarden

							The function begins by using an if statement to determine whether or not r is one. If it is, the sum is computed as a * n and the function immediately returns this value without executing the remaining lines in the function’s body. When r is not equal to one, the body of the if statement is skipped and the sum of the first n terms is computed and stored in s. Then the value stored in s is returned to the location from which the function was called.
							The following program demonstrates the sumGeometric function by comput- ing sums until the user enters zero for a. Each sum is computed inside the function and then returned to the location where the function was called. Then the returned value is stored in the total variable using an assignment statement. A subsequent statement displays total before the program goes on and reads the values for another sequence from the user.
				</section>
				<section>
							## Returnwaarden

							```python
							def main():
							# Read the initial value for the first sequence
							init = float(input("Enter the value of a (0 to quit): "))
							# While the initial value is non-zero
							while init != 0:
							# Read the ratio and number of terms
							ratio = float(input("Enter the ratio, r: "))
							num = int(input("Enter the number of terms, n: "))
							# Compute and display the total
								total = sumGeometric(init, ratio, num)
								print("The sum of the first", num, "terms is", total)
							# Read the initial value for the next sequence
								init = float(input("Enter the value of a (0 to quit): "))
							# Call the main function
							main()
							```
				</section>
				<section>
							## Importing Functions into Other Programs

							One of the benefits of using functions is the ability to write a function once and then call it many times from different locations. This is easily accomplished when the function definition and call locations all reside in the same file. The function is defined and then it is called by using its name, followed by parentheses containing any arguments.
At some point you will find yourself in the situation where you want to call a function that you wrote for a previous program while solving a new problem. New programmers (and even some experienced programmers) are often tempted to copy the function from the file containing the old program into the file containing the new one, but this is an undesirable approach. Copying the function results in the same code residing in two places. As a result, when a bug is identified it will need to be corrected twice. A better approach is to import the function from the old program into the new one, similar to the way that functions are imported from Python’s built-in modules.
				</section>
				<section>
							## Importing Functions into Other Programs

							Functions from an old Python program can be imported into a new one using the import keyword, followed by the name of the Python file that contains the functions of interest (without the .py extension). This allows the new program to call all of the functions in the old file, but it also causes the program in the old file to execute. While this may be desirable in some situations, we often want access to the old program’s functions without actually running the program. This is nor- mally accomplished by creating a function named main that contains the statements needed to solve the problem. Then one line of code at the end of the file calls the main function. Finally, an if statement is added to ensure that the main function does not execute when the file has been imported into another program, as shown below:
if __name__ == "__main__":
  main()
This structure should be used whenever you create a program that includes functions that you might want to import into another program in the future.


				</section>


				<section class="chapter">
							## Labo-voorbereidende oefeningen
				</section>
				<section>
							## Oefening 1
				</section>
				<section>
							## Oefening 2
				</section>
				<section>
							## Oefening 3
				</section>
				<section>
							## Python Development - les 3 - kristof.michiels01@ap.be
				</section>
	</body>
</html>