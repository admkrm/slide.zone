<!doctype html>
<html>
	<head>
		<title>Python Development: Les 11</title>
		<link rel="stylesheet" type="text/css" href="../css/reset.css">
		<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../highlight/styles/googlecode.css">
		<link href="https://fonts.googleapis.com/css?family=Karla:700|Open+Sans" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../css/agnes.css">
		<link rel="stylesheet" type="text/css" href="../css/htmlgallery.css">
		<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/194554/scroll-converter.min.js'></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script src='../highlight/highlight.pack.js'></script>
		<script src="../js/script.js" defer></script>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="utf-8">
	</head>
	<body data-markdown="true">
				<section>
							# Python Development
							## Objecten en klassen (2)
							#### Kristof Michiels
				</section>
				<section>
							## Inhoud
							- Objectgeoriënteerd programmeren
							- Compositie en aggregatie
							- Magische methods
							- Abstracte basisklassen
				</section>
				<section class="chapter">
							## Objectgeoriënteerd programmeren
				</section>
				<section>
							## Objectgeoriënteerd programmeren
							- Techniek die mogelijk maakt om variabelen en functies te groeperen
							- Dat groeperen gebeurt binnen een data type dat we een klasse noemen
							- Je bouwt een systeem dat bestaat uit objecten
							- Door je code te organiseren binnen klasses kan je je programma opdelen in kleinere onderdelen die eenvoudiger te begrijpen en te debuggen zijn
				</section>
				<section>
							## Objectgeoriënteerd programmeren
							- Voor kleinere programma's: weinig organisatiewinst, meer werk en complexiteit
							- OOP (bij Python) is optioneel
							- Python core developer Jack Diederich's PyCon 2012: “Stop Writing Classes” (https://youtu.be/o9pEzgHorH0/ )
							- In sommige gevallen werkt een eenvoudige functie of module beter
							- Desalniettemin: terecht populaire keuze en vaak de efficientste manier
				</section>
				<section>
							## Software modellen bouwen van fysieke objecten
							- Als we fysieke objecten beschrijven verwijzen we vaak naar hun eigenschappen
								- Een auto: kleur, afmetingen, merk, aantal deuren ...
							- Sommige objecten hebben eigenschappen die slaan op hen en niet op andere objecten
								- Een doos: afgesloten, open, leeg, vol. Niet van toepassing op bvb een fiets
							- Sommige objecten zijn in staat om acties te vervullen. 
								- Een auto kan vooruit gaan, achteruit, links en rechts
				</section>
				<section>
							## Software modellen bouwen van fysieke objecten
							- Als we objecten uit ons leven willen modelleren in code: beslissen welke eigenschappen het object zullen representeren en welke operaties het object kan vervullen
							- Dit noemt men de _state_ (data) en _behavior_ (gedrag of acties) van een object
				</section>
				<section>
							## State en behavior: een procedureel voorbeeld
							``` python
							def zetAan():
								global schakelaarIsAan
								schakelaarIsAan = True

							def zetUit():
								global schakelaarIsAan
								schakelaarIsAan = False

							schakelaarIsAan = False
							print(schakelaarIsAan)
							zetAan()
							print(schakelaarIsAan)
							zetUit()
							print(schakelaarIsAan)
							zetUit()
							print(schakelaarIsAan)
							```
				</section>
				<section>
							## _State_ en _behavior_: een procedureel voorbeeld
							- De schakelaar kan in 2 posities zijn: aan of uit
							- Om de _state_ te modelleren hebben we hier een Booleaanse variabele nodig
								- We noemen hem schakelaarIsAan: True betekent aan, False betekent uit
								- Initieel staat de schakelaar op uit
							- _Behavior_: de schakelaar kan twee acties uitvoeren, "zet aan" en "zet uit"
								- Hiervoor bouwen we 2 functies, zetAan() en zetUit()
								- Deze zetten de waarde van de variabele op respectievelijk aan en uit
							- Op het einde is er wat testcode toegevoegd die wat met de schakelaar "speelt" 
				</section>
				<section>
							## Richting OO...
							- Voorgaande is een zeer eenvoudig voorbeeld
							- Je botst snel op de limieten van deze aanpak wanneer je een tweede schakelaar wil aanmaken
							- De code is niet erg herbruikbaar, terwijl dit net het doel is van functies
							- Zondigt tegen het [DRY principe](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 
							- We gaan deze code opnieuw schrijven volgens de OO principes
				</section>
				<section>
							## Het procedureel voorbeeld herschreven

							```python
							class LichtSchakelaar():
								def __init__(self):
									self.schakelaarIsAan = False
									
								def zetAan(self):
									# zet de schakelaar aan
									self.schakelaarIsAan = True
									
								def zetUit(self):
									# zet de schakelaar uit
									self.schakelaarIsAan = False

							schakelaar1 = LichtSchakelaar()
							print(schakelaar1.schakelaarIsAan)
							schakelaar1.zetAan()
							print(schakelaar1.schakelaarIsAan)
							```
				</section>
				<section>
							## Het procedureel voorbeeld herschreven
							- De klasse definieert een enkele variabele, schakelaarIsAan. Deze wordt geïnitialiseerd in een functie.
							- Ze bevat nog twee andere functies voor het gedrag: zetAan() en zetUit()
							- Net zoals functies moeten aangeroepen worden dien je Python expliciet te vertellen om een object van de klasse te maken
								- In onze code dragen we op om de klasse te vinden
								- Er een object uit te creëren (of instantiëren)
								- En het resulterende object toe te kennen aan de variabele schakelaar1
				</section>
				<section>
							## Klassen onderbrengen in modules...
							
							```Python
							#module.py
							class Boek():
								def __init__(self, titel):
									self.titel = titel
							```

							```Python
							import module

							boek1 = module.Boek("Brave New World")
							boek2 = module.Boek("World War Z")

							print(boek1)
							print(boek1.titel)
							```

							Doe je op dezelfde manier als met functies. Het houdt je code georganiseerd en gestructureerd.
				</section>
				<section class="chapter">
							## Compositie en aggregatie
				</section>
				<section>
							## Compositie en aggregatie
							
							- Overerving is een zeer bruikbare techniek om een systeem van klassen uit te bouwen
								- Het is handig wanneer klassenfunctionaleit kunnen delen vanuit een base klasse (een "is een"-relatie)
								- Maar het kan uitnodigen tot de vorming van zeer complexe hiërarchieën 
				</section>
				<section>
							## Compositie en aggregatie
							
							- Vaak zijn compositie en aggregatie nuttiger om een systeem van klassen te vormen
								- Dit is het bouwen van complexe objecten uit andere meer eenvoudige objecten
								- Bij compositie is één object een deel van een ander object (een "heeft-een"-relatie)
								- Aggregatie drukt ook een "heeft-een" relatie uit, maar deze is iets losser: een object gebruikt een ander object, maar ze kunnen los van elkaar bestaan
							- Verschillende ideeën kunnen geïsoleerd worden en in hun eigen klassen geplaatst
							- En uiteraard: overerving en compositie kunnen gecombineerd worden
				</section>
				<section>
							## Compositie en aggregatie: basisvoorbeeld

							```Python
							class Soort():
								def __init__(self, naam):
									self.naam = naam
							
							class Kunstenaar():
								def __init__(self, naam):
									self.naam = naam
							
							class Kunstwerk():
								def __init__(self, soort, kunstenaar):
									self.soort = soort
									self.kunstenaar = kunstenaar

								def __str__(self):
									return f"Dit kunstwerk is een {self.soort.naam} en werd gemaakt door
									{self.kunstenaar.naam}"
							```
				</section>
				<section>
							## Compositie en aggregatie: een voorbeeld

							```Python
							een_schilderij = Soort("schilderij")
							een_kunstenaar = Kunstenaar("Francis Picabia")
							een_kunstwerk = Kunstwerk(een_schilderij, een_kunstenaar)
							print(een_kunstwerk) 
							# Dit kunstwerk is een schilderij en werd gemaakt door Francis Picabia
							```
				</section>
				<section>
							## Compositie en aggregatie: een voorbeeld (2)

							```Python
							class Boek():
								def __init__(self, titel, prijs, auteur=None):
									self.titel = titel
									self.prijs = prijs
									self.auteur = auteur
									self.hoofdstukken = []

								def voeghoofdstuktoe(self, hoofdstuk):
									self.hoofdstukken.append(hoofdstuk)

								def getboekpaginatelling(self):
									resultaat = 0
									for h in self.hoofdstukken:
										resultaat += h.paginatelling
									return resultaat
							```
				</section>
				<section>
							## Compositie en aggregatie: een voorbeeld (2)

							```Python
							class Auteur():
								def __init__(self, voornaam, familienaam):
									self.voornaam = voornaam
									self.familienaam = familienaam

								def __str__(self):
									return f"{self.voornaam} {self.familienaam}"


							class Hoofdstuk():
								def __init__(self, naam, paginatelling):
									self.naam = naam
									self.paginatelling = paginatelling
							```
				</section>
				<section>
							## Compositie en aggregatie: een voorbeeld (2)

							```Python
							auteur1 = Auteur("Leo", "Tolstoy")
							boek1 = Boek("War and Peace", 39.95, auteur1)

							boek1.voeghoofdstuktoe(Hoofdstuk("Hoofdstuk 1", 102))
							boek1.voeghoofdstuktoe(Hoofdstuk("Hoofdstuk 2", 91))
							boek1.voeghoofdstuktoe(Hoofdstuk("Hoofdstuk 3", 124))

							print(boek1.titel)
							print(boek1.auteur)
							print(boek1.getboekpaginatelling())
							```
				</section>
				<section class="chapter">
							## Magische Methods
				</section>
				<section>
							## Magische Methods

							- Magische methods (_magic methods_ in het Engels) zijn speciale methods in Python
							- Ze beginnen en eindigen telkens met dubbele underscores en worden hierdoor ook dunder-methods genoemd
							- Ze zijn niet bedoeld om rechtstreeks door jou te worden aangeroepen. Het aanroepen gebeurt intern vanuit de klasse bij een bepaalde actie
							- Enkele voorbeelden: \_\_init\_\_ (zagen we reeds in de vorige les), \_\_add\_\_, \_\_len\_\_, \_\_repr\_\_...
				</section>
				<section>
							## Magische methods

							- Wanneer je in je code twee objecten bij elkaar optelt, zoals getal = 3 + 8, hoe weten deze integer objecten hoe ze de "+" moeten implementeren? 
							- Of in het geval van strings:  kunstenaar = "Damien" + " " + "Hirst", hoe weet Python hoe deze strings aan elkaar te plakken?  
							- En in beide bovenstaande voorbeelden: hoe weten de objecten getal en kunstenaar hoe ze de "=" moeten implementeren?
							- Het antwoord is telkens: magische methods :-)
				</section>
                <section>
							## Magische Methods: voorbeeld
							
							- We vertrekken in dit voorbeeld van een eenvoudige klasse Kunstenaar. We maken een gelijk_aan method die de naam case-neutraal vergelijkt
							- Het zou interessant zijn om 2 objecten te kunnen vergelijken en magische methods maken dit mogelijk


							```Python
							class Kunstenaar():
							    def __init__(self, naam):
							        self.naam = naam
							    def gelijk_aan(self, andere_kunstenaar):
							        return self.naam.lower() == andere_kunstenaar.naam.lower()

							kunstenaar1 = Kunstenaar("Andy Warhol")
							kunstenaar2 = Kunstenaar("ANDY WARHOL")
							print(kunstenaar1.gelijk_aan(kunstenaar2)) # True
							```
                </section>
				<section>
							## Magische Methods: voorbeeld
							
							- Het enige dat we moeten doen is de method gelijk_aan te vervangen door de magische method \_\_eq\_\_

							```Python
							class Kunstenaar():
							    def __init__(self, naam):
							        self.naam = naam
							    def __eq__(self, andere_kunstenaar):
							        return self.naam.lower() == andere_kunstenaar.naam.lower()

							kunstenaar1 = Kunstenaar("Andy Warhol")
							kunstenaar2 = Kunstenaar("ANDY WARHOL")
							print(kunstenaar1 == kunstenaar2) # True
							```
				</section>
				<section>
							## Magische methods voor vergelijkingen

							- \_\_eq\_\_( self, ander)	self == ander 
							- \_\_ne\_\_( self, ander) self != ander 
							- \_\_lt\_\_( self, ander) self < ander 
							- \_\_gt\_\_( self, ander) self > ander
							- \_\_le\_\_( self, ander) self <= ander
							- \_\_ge\_\_( self, ander) self >= ander

							Overzicht van magische methods: https://docs.python.org/3/reference/datamodel.html#special-method-names
				</section>
				<section>
							## Magische methods voor wiskundige operaties

							- \_\_add\_\_( self, ander) self + ander
							- \_\_sub\_\_( self, ander) self – ander
							- \_\_mul\_\_( self, ander) self * other 
							- \_\_floordiv\_\_( self, ander) self // ander
							- \_\_truediv\_\_( self, ander) self / ander
							- \_\_mod\_\_( self, ander) self % ander
							- \_\_pow\_\_( self, ander) self ** ander

							Overzicht van magische methods: https://docs.python.org/3/reference/datamodel.html#special-method-names
				</section>
				<section>
							## Andere vaak gebruikte magische methods

							- Naast \_\_init\_\_ ga je wellicht het meest gebruik maken van \_\_str\_\_ in je eigen methods
							- Met deze method geef je mee hoe het object moet worden geprint. Het wordt gebruikt door print() en str()
							- De interactieve interpreter gebruikt de \_\_repr\_\_ method om variabelen te outputten 

							```Python
							class Kunstenaar():
							    def __init__(self, naam):
							        self.naam = naam
							    def __str__(self):
							        return f"Hallo, ik ben {self.naam}!"

							kunstenaar1 = Kunstenaar("Andy Warhol")
							print(kunstenaar1) # Hallo, ik ben Andy Warhol
							```
				</section>
				<section class="chapter">
							## Abstracte basisklassen
				</section>
				<section>
							## Abstracte basisklassen
							- Je wil een basisklasse voorzien die een template biedt voor overerving naar andere klassen
							- Enkel een blauwdruk, kan niet geïnstantieerd worden
							- Subklassen worden dan concrete implementaties van dat idee
							- Je wil afdwingen dat bepaalde methods moeten geïmplementeerd worden in de subklassen
				</section>
				<section>
							## Abstracte basisklassen

							```Python
							from abc import ABC, abstractmethod

							class GrafischeVorm(ABC):
								def __init__(self):
									super().__init__()

								@abstractmethod
								def berekenOppervlakte(self):
									pass

							class Cirkel(GrafischeVorm):
								def __init__(self, straal):
									self.straal = straal

								def berekenOppervlakte(self):
									return 3.14 * (self.straal ** 2)
							```
				</section>
				<section>
							## Abstracte basisklassen

							```Python
							class Vierkant(GrafischeVorm):
								def __init__(self, zijde):
									self.zijde = zijde

								def berekenOppervlakte(self):
									return self.zijde * self.zijde

							cirkel1 = Cirkel(10)
							print(cirkel1.berekenOppervlakte())
							vierkant1 = Vierkant(12)
							print(vierkant1.berekenOppervlakte())
							```
				</section>
				<section>
							## Abstracte basisklassen
							- We maken gebruik van de ABC-module van de standard library
							- We gebruiken de @abstractmethod decorator om aan te geven dat een method abstract is en elke subklasse deze method moet overschrijven
				</section>
				<section>
							## Interfaces
							- Python geen expliciete taalondersteuning voor interfaces
							- Een soort contract of belofte om een bepaald gedrag of mogelijkheden te hebben
							- Hier: combinatie van meervoudige overerving en ABC
							- We zouden de JSONify klasse kunnen gebruiken als interface voor een andere klasse
				</section>
				<section>
							## Interfaces

							```Python
							from abc import ABC, abstractmethod

							class GrafischeVorm(ABC):
								def __init__(self):
									super().__init__()

								@abstractmethod
								def berekenOppervlakte(self):
									pass

							class JSONify(ABC):
								@abstractmethod
								def toJSON(self):
									pass
							```
				</section>
				<section>
							## Interfaces

							```Python
							class Cirkel(GrafischeVorm, JSONify):
								def __init__(self, straal):
									self.straal = straal

								def berekenOppervlakte(self):
									return 3.14 * (self.straal ** 2)

								def toJSON(self):
									return f"{{ \"cirkel\": {str(self.berekenOppervlakte())} }}"


							cirkel1 = Cirkel(10)
							print(cirkel1.berekenOppervlakte())
							print(cirkel1.toJSON())
							```
				</section>
				<section>
							## Python Development - les 11 - kristof.michiels01@ap.be
				</section>
	</body>
</html>