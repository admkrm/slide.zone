<!doctype html>
<html>
	<head>
		<title>Python OOP / development: exceptions en foutafhandeling</title>
		<link rel="stylesheet" type="text/css" href="../css/reset.css">
		<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../highlight/styles/googlecode.css">
		<link href="https://fonts.googleapis.com/css?family=Karla:700|Open+Sans" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="../css/agnes.css">
		<link rel="stylesheet" type="text/css" href="../css/htmlgallery.css">
		<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/194554/scroll-converter.min.js'></script>
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script src='../highlight/highlight.pack.js'></script>
		<script src="../js/script.js" defer></script>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="utf-8">
	</head>
	<body data-markdown="true">
				<section>
							# Python OOP / development
							## Exceptions en foutafhandeling
							#### Kristof Michiels
				</section>
				<section>
							## Exceptions
							- Wanneer tijdens het lopen (de zgn. runtime) van een programma een fout optreedt:
								- wordt een __exception object__ aangemaakt
								- __stopt het programma__ met de verdere uitvoering
								- schrijft Python de __traceback__ naar de console, die eindigt met een beschrijving vd exception
							- Over welke fouten hebben we het? Heel vaak langs invoerkant
								- Bvb de gebruiker kan een niet-numerieke waarde ingeven waar er één wordt verwacht 
								- Bvb de gebruiker kan verkeerdelijk een niet-bestaande bestandsnaam meegeven 
				</section>
				<section>
							## Voorbeelden van exceptions (via de interactieve shell)

							Een string die geen getalwaarde bevat omzetten naar een integer resulteert in een _ValueError_ exception:

							```Bash
							>>> int("hallo")
							Traceback (most recent call last):
							File "<stdin>", line 1, in <module>
							ValueError: invalid literal for int() with base 10: 'hallo'
							```

							Delen door 0 levert een _ZeroDivisionError_ exception op: 

							```Bash
							>>> print(20/0)
							Traceback (most recent call last):
							File "<interactive input>", line 1, in <module>
							ZeroDivisionError: integer division or modulo by zero
							```
				</section>
				<section>
							## Voorbeelden van exceptions (via de interactieve shell)

							Een niet-bestaand list-item resulteert in een _IndexError_ exception:

							```Bash
							>>> mijn_list = []
							>>> print(mijn_list[5])
							Traceback (most recent call last):
							File "<interactive input>", line 1, in <module>
							IndexError: list index out of range
							```

							Een item toevoegen aan een tuple (immutable!) levert een TypeError exception op: 

							```Bash
							>>> mijn_tuple = ("a", "e", "i", "o")
							>>> mijn_tuple[2] = "u" 
							Traceback (most recent call last):
							File "<interactive input>", line 1, in <module>
							TypeError: 'tuple' object does not support item assignment
							```
				</section>
				<section>
							## Omgaan met exceptions

							- In elk van de bovenstaande voorbeelden bestaat het foutbericht op de laatste regel uit twee delen (gescheiden door een dubbelpunt):  het type fout en de bijzonderheden over deze fout 
							- In bepaalde gevallen willen we een gebeurlijke exception niet het programma laten stoppen
							- We kunnen actie ondernemen als antwoord op de exception en daarna het programma laten verder gaan
							- We kunnen hiervoor het try-statement gebruiken en plaatsen rond een code-blok die onder bepaalde omstandigheden tot een exception zou kunnen leiden
				</section>
				<section>
							## Try en except

							- In dit voorbeeld verzoeken we de gebruiker een bestandsnaam in te voeren en proberen dit bestand vervolgens te openen
					
							```Python
							mijn_bestand_naam = input("Geef een bestandsnaam: ")
							try:
								mijn_bestand = open(mijn_bestand_naam, "r")
							except:
								print(f"Het bestand {mijn_bestand_naam} kon niet worden gevonden.")
							```
				</section>
				<section>
							## Try en except

							- In het bovenstaande voorbeeld wordt elke mogelijk voorkomende exception afgehandeld door een algemene except-blok
							- We kunnen gaan verfijnen en expliciet een FileNotFoundError exception afhandelen
							- Hier zie je dat we de toepassing zelf expliciet beëindigen met de quit()- functie

							```Python
							antwoord = input("Geef een bestandsnaam: ")
							try:
								mijn_bestand = open(antwoord, "r")
							except FileNotFoundError:
								print("Het bestand kon niet worden gevonden. Programma wordt afgesloten...") 
								quit()
							```
				</section>
				<section>
							## Try en except

							- Wanneer een exception zich voordoet binnen een try-blok stopt de verdere uitvoering binnen deze blok en springt de uitvoering onmiddellijk naar de aangewezen except-blok 
							- Elke except-blok kan aangeven welk soort exception het wil opvangen door na het except trefwoord onmiddellijk het type exception mee te geven
							- Een except-blok zonder specifieke exception zal elk type exception opvangen (die nog niet door een specifieke exception werd behandeld)
							- In plaats daarvan voeren we het except-blok uit en handelen we de exception af. Deze wordt enkel in het geval van een fout uitgevoerd
				</section>
				<section>
							## Try, except, finally

							- Het try statement bestaat uit drie verschillende onderdelen: try, except en finally
							- _Try_ voert en observeert de statements in het codeblok uit
							- Indien er zich geen exceptions voordoen dat wordt de except-blok overgeslagen
							- Indien wel dan worden de statements in de _except_-blok uitgevoerd en dan gaat de toepassing verder
							- Er mogen verschillende _except_-blokken worden toegevoegd, elk met een specifiek af te handelen exception
							- _Finally_ bevat code die mag uitgevoerd worden nadat de exception is afgehandeld. Deze blok mag weggelaten worden

				</section>
				<section>
							## Try en except

							```Python
							antwoord = input("Geef een bestandsnaam: ")
							bestand_geopend = False
							while bestand_geopend == False:
								try:
									mijn_bestand = open(antwoord, "r")
									bestand_geopend = True
								except FileNotFoundError:
									print("Het bestand kon niet worden gevonden") 
									antwoord = input("Geef een bestandsnaam: ")
							```

							- Hier passen we bovenstaande code aan zodat het programma blijft proberen tot een bestaand bestand werd gevonden
				</section>
				<section>
							## Encapsuleren in een functie

							- exists which takes a filename and returns true if the file exists, false if it doesn’t:

							```Python
							def exists(filename):
								try:
									f = open(filename)
									f.close()
									return True 
								except:
									return False 
							```

							The function we’ve just shown is not one we’d recommend. It opens and closes the file, which is semantically different from asking “does it exist?”. How? Firstly, it might update some timestamps on the file. Secondly, it might tell us that there is no such file if some other program already happens to have the file open, or if our permission settings don’t allow us to open the file.

							Python provides a module called os.path within the os module. It provides a number of useful functions to work with paths, files and directories, so you should check out the help.

							```Python
							import os

							# This is the preferred way to check if a file exists.
							if os.path.isfile("c:/temp/testdata.txt"):
```
				</section>
				<section>
							## Meerdere _except_-blokken

							We can use multiple except clauses to handle different kinds of exceptions (see the Errors and Exceptions lesson from Python creator Guido van Rossum’s Python Tutorial for a more complete discussion of exceptions). So the program could do one thing if the file does not exist, but do something else if the file was in use by another program.

							https://docs.python.org/3/tutorial/index.html
				</section>
				<section>
							## Raising our own exceptions

							Can our program deliberately cause its own exceptions? If our program detects an error condition, we can raise an exception. Here is an example that gets input from the user and checks that the number is non-negative:
							
							Line 5 creates an exception object, in this case, a ValueError object, which encapsulates specific information about the error. Assume that in this case function A called B which called C which called D which called get_age. The raise statement on line 6 carries this object out as a kind of “return value”, and immediately exits from get_age() to its caller D. Then D again exits to its caller C, and C exits to B and so on, each returning the exception object to their caller, until it encounters a try ... except that can handle the exception. We call this “unwinding the call stack”.
							
							ValueError is one of the built-in exception types which most closely matches the kind of error we want to raise. The complete listing of built-in exceptions can be found at the Built-inExceptions section of the Python Library Reference , again by Python’s creator, Guido van Rossum.
							
							If the function that called get_age (or its caller, or their caller, …) handles the error, then the program can carry on running; otherwise, Python prints the traceback and exits:
				</section>
				<section>
							## The finally clause of the try statement

							A common programming pattern is to grab a resource of some kind — e.g. we create a window for turtles to draw on, or we dial up a connection to our internet service provider, or we may open a file for writing. Then we perform some computation which may raise an exception, or may work without any problems.
							
							Whatever happens, we want to “clean up” the resources we grabbed — e.g. close the window, disconnect our dial-up connection, or close the file. The finally clause of the try statement is the way to do just this. Consider this (somewhat contrived) example:
				</section>

				
				<section>
							## Python OOP / development - foutafhandeling - kristof.michiels01@ap.be
				</section>
	</body>
</html>